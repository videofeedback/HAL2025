class MainApp {
    constructor() {
        this.isConnected = false;
        this.connectionStatus = null;
        this.disconnectButton = null;
        this.responseDisplay = null;
        this.responseAudio = null;
        this.playResponseButton = null;
        
        this.currentResponse = null;
        this.responseStartTime = null;
        
        this.initializeElements();
        this.setupEventListeners();
        this.initialize();
    }
    
    initializeElements() {
        this.connectionStatus = document.getElementById('connectionStatus');
        this.disconnectButton = document.getElementById('disconnectButton');
        
        // Response display elements
        this.responseText = document.getElementById('responseText');
        this.responseProvider = document.getElementById('responseProvider');
        this.responseModel = document.getElementById('responseModel');
        this.responseTime = document.getElementById('responseTime');
        this.playResponseButton = document.getElementById('playResponseButton');
        this.responseAudio = document.getElementById('responseAudio');
    }
    
    setupEventListeners() {
        // Disconnect button
        if (this.disconnectButton) {
            this.disconnectButton.addEventListener('click', this.handleDisconnect.bind(this));
        }
        
        // Play response button
        if (this.playResponseButton) {
            this.playResponseButton.addEventListener('click', this.playResponse.bind(this));
        }
        
        // WebSocket events
        window.addEventListener('connectionEstablished', this.handleConnectionEstablished.bind(this));
        window.addEventListener('response', this.handleResponse.bind(this));
        window.addEventListener('audioResponse', this.handleAudioResponse.bind(this));
        window.addEventListener('serverError', this.handleServerError.bind(this));
        
        // Global error handling
        window.addEventListener('error', this.handleGlobalError.bind(this));
        window.addEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this));
    }
    
    async initialize() {
        try {
            this.updateConnectionStatus(false);
            this.updateUI(false);
            
            // Connect to WebSocket
            await window.wsClient.connect();
            
        } catch (error) {
            console.error('Failed to initialize app:', error);
            this.showError('Failed to connect to server: ' + error.message);
        }
    }
    
    handleConnectionEstablished(event) {
        console.log('App: Connection established');
        this.isConnected = true;
        this.updateConnectionStatus(true);
        this.updateUI(true);
        
        if (window.selfAwarenessUI) {
            window.selfAwarenessUI.logAlert('Application connected and ready', 'success');
        }
    }
    
    handleResponse(event) {
        const data = event.detail;
        console.log('App: Response received:', data);
        
        // Calculate response time
        const responseTime = this.responseStartTime ? 
            (Date.now() - this.responseStartTime) / 1000 : 0;
        
        this.displayResponse(data, responseTime);
        this.currentResponse = data;
        
        // TTS is now automatically generated by the backend and sent as audio_response
        // No need to request it here - just wait for the audio_response event
        
        // Update self-awareness monitor
        if (window.selfAwarenessUI) {
            window.selfAwarenessUI.updateResponseTime(responseTime);
        }
    }
    
    handleAudioResponse(event) {
        const data = event.detail;
        console.log('App: Audio response received');
        
        if (data.audio_data && this.responseAudio) {
            // Convert base64 to blob and create URL
            const audioBlob = this.base64ToBlob(data.audio_data, 'audio/wav');
            const audioUrl = URL.createObjectURL(audioBlob);
            
            this.responseAudio.src = audioUrl;
            this.playResponseButton.disabled = false;
            
            // Auto-play the audio response
            this.responseAudio.play().then(() => {
                console.log('Audio response playing automatically');
                if (window.selfAwarenessUI) {
                    window.selfAwarenessUI.logAlert('ðŸ”Š Playing audio response', 'success');
                }
            }).catch(error => {
                console.error('Auto-play failed:', error);
                if (window.selfAwarenessUI) {
                    window.selfAwarenessUI.logAlert('Audio ready - click play button (auto-play blocked)', 'warning');
                }
            });
        }
    }
    
    displayResponse(data, responseTime = 0) {
        // Update response text
        if (this.responseText) {
            this.responseText.textContent = data.text || 'No response received';
        }
        
        // Update metadata
        if (this.responseProvider) {
            this.responseProvider.textContent = `Provider: ${data.provider || '--'}`;
        }
        
        if (this.responseModel) {
            this.responseModel.textContent = `Model: ${data.model || '--'}`;
        }
        
        if (this.responseTime) {
            this.responseTime.textContent = `Time: ${responseTime.toFixed(1)}s`;
            
            // Color code response time
            if (responseTime < 2.0) {
                this.responseTime.style.color = '#28a745';
            } else if (responseTime < 5.0) {
                this.responseTime.style.color = '#ffc107';
            } else {
                this.responseTime.style.color = '#dc3545';
            }
        }
    }
    
    async requestTTS(text) {
        try {
            // This would be implemented when TTS is integrated
            // For now, we'll simulate the request
            console.log('TTS requested for:', text);
            
        } catch (error) {
            console.error('TTS request failed:', error);
        }
    }
    
    playResponse() {
        if (this.responseAudio && this.responseAudio.src) {
            this.responseAudio.play().catch(error => {
                console.error('Audio playback failed:', error);
                this.showError('Audio playback failed: ' + error.message);
            });
        } else {
            this.showError('No audio available for playback');
        }
    }
    
    handleServerError(event) {
        const error = event.detail;
        console.error('App: Server error:', error);
        this.showError('Server error: ' + error.message);
    }
    
    handleGlobalError(event) {
        console.error('Global error:', event.error);
        if (window.selfAwarenessUI) {
            window.selfAwarenessUI.logAlert(`Global error: ${event.error.message}`, 'error');
        }
    }
    
    handleUnhandledRejection(event) {
        console.error('Unhandled promise rejection:', event.reason);
        if (window.selfAwarenessUI) {
            window.selfAwarenessUI.logAlert(`Promise rejection: ${event.reason}`, 'error');
        }
    }
    
    async handleDisconnect() {
        try {
            if (window.selfAwarenessUI) {
                window.selfAwarenessUI.logAlert('Disconnecting and terminating sessions...', 'warning');
            }
            
            // Disconnect WebSocket
            await window.wsClient.disconnect();
            
            // Update UI
            this.isConnected = false;
            this.updateConnectionStatus(false);
            this.updateUI(false);
            
            // Clear current data
            this.clearResponse();
            
            if (window.selfAwarenessUI) {
                window.selfAwarenessUI.logAlert('Disconnected successfully', 'info');
            }
            
        } catch (error) {
            console.error('Disconnect error:', error);
            this.showError('Disconnect failed: ' + error.message);
        }
    }
    
    updateConnectionStatus(connected) {
        if (this.connectionStatus) {
            if (connected) {
                this.connectionStatus.textContent = 'Connected';
                this.connectionStatus.className = 'status-indicator connected';
            } else {
                this.connectionStatus.textContent = 'Disconnected';
                this.connectionStatus.className = 'status-indicator disconnected';
            }
        }
    }
    
    updateUI(connected) {
        // Update component states
        if (window.voiceInterface) {
            window.voiceInterface.setEnabled(connected);
        }
        
        if (window.textInterface) {
            window.textInterface.setEnabled(connected);
        }
        
        if (window.providerSelector) {
            window.providerSelector.setEnabled(connected);
        }
        
        // Update disconnect button
        if (this.disconnectButton) {
            this.disconnectButton.disabled = !connected;
        }
        
        // Reset interfaces if disconnected
        if (!connected) {
            if (window.voiceInterface) {
                window.voiceInterface.reset();
            }
            
            if (window.textInterface) {
                window.textInterface.clear();
            }
        }
    }
    
    clearResponse() {
        if (this.responseText) {
            this.responseText.textContent = 'Waiting for input...';
        }
        
        if (this.responseProvider) {
            this.responseProvider.textContent = 'Provider: --';
        }
        
        if (this.responseModel) {
            this.responseModel.textContent = 'Model: --';
        }
        
        if (this.responseTime) {
            this.responseTime.textContent = 'Time: --';
            this.responseTime.style.color = '#718096';
        }
        
        if (this.responseAudio) {
            this.responseAudio.src = '';
        }
        
        if (this.playResponseButton) {
            this.playResponseButton.disabled = true;
        }
        
        this.currentResponse = null;
    }
    
    showError(message) {
        console.error('App error:', message);
        
        if (window.selfAwarenessUI) {
            window.selfAwarenessUI.logAlert(message, 'error');
        }
        
        // Could also show toast notification or modal
        this.showToast(message, 'error');
    }
    
    showToast(message, type = 'info') {
        // Simple toast notification
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: ${type === 'error' ? '#dc3545' : '#17a2b8'};
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            z-index: 10000;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            animation: slideDown 0.3s ease;
        `;
        
        document.body.appendChild(toast);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (toast.parentNode) {
                toast.style.animation = 'slideUp 0.3s ease';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.remove();
                    }
                }, 300);
            }
        }, 5000);
    }
    
    base64ToBlob(base64, mimeType) {
        const byteCharacters = atob(base64);
        const byteNumbers = new Array(byteCharacters.length);
        
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: mimeType });
    }
    
    // Public methods
    getConnectionStatus() {
        return this.isConnected;
    }
    
    getCurrentResponse() {
        return this.currentResponse;
    }
    
    setResponseStartTime() {
        this.responseStartTime = Date.now();
    }
    
    async reconnect() {
        try {
            await this.initialize();
        } catch (error) {
            this.showError('Reconnection failed: ' + error.message);
        }
    }
}

// Add CSS animations for toast
const toastStyles = document.createElement('style');
toastStyles.textContent = `
    @keyframes slideDown {
        from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
        to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }
    
    @keyframes slideUp {
        from { transform: translateX(-50%) translateY(0); opacity: 1; }
        to { transform: translateX(-50%) translateY(-100%); opacity: 0; }
    }
`;
document.head.appendChild(toastStyles);

// Initialize main app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.mainApp = new MainApp();
});